#!/usr/bin/env ruby

require 'fileutils'
require 'optparse'
require 'solrtasks'
require 'pathname'

options = {
    :cache_dir => File.expand_path(".solrtask", "~"),
    :url => 'http://localhost:8983/solr',
    :install_base => File.expand_path("solr-dir"),
    :default_version => '6.3.0',
}

version_set = false

current_path = Pathname.getwd
def_cache = Pathname.new(options[:cache_dir]).relative_path_from(current_path)
def_install = Pathname.new(options[:install_base]).relative_path_from(current_path)
def_solr = Pathname.new(options[:install_base]).join("solr-#{options[:version]}").relative_path_from(current_path)

_tasks = %w[status start stop install collections cores schema fields]

hopts = OptionParser.new do |opts|

    opts.banner = "Usage: solrtask [options] task [core/collection]"
    opts.banner << "\ntask is one of:\n\t#{_tasks.join("|")}"
    
    opts.banner << "\n\nThe final argument is required for the 'schema' and 'fields' tasks.\n\nOptions: \n\n"


    opts.on('-uURL', '--url=URL', "URL of the solr server to query",
        "default: #{options[:url]}") do |url|
        options[:url] = url
    end

    opts.on('-iDIRECTORY', '--install-base=DIRECTORY', "Parent directory for Solr installs", "default: ./#{def_install}") do |the_dir|
        options[:install_base] = the_dir
    end

    opts.on('-sDIRECTORY', '--solr-directory=DIRECTORY', "Complete path to Solr installation", 
        "\t*** OVERRIDES -i ***",
        "default ./#{def_solr}") do |the_dir|
        opts[:install_dir] = the_dir
    end

    opts.on('-cCACHEDIR', '--cache-dir=CACHEDIR', "Directory to store downloads", "default: #{options[:cache_dir]}") do |cd|
        options[:cache_dir] = cd
    end

    opts.on('-v', '--version [VERSION]', 'The solr version to be installed',
        "default: #{options[:default_version]}") do |version|
        if version.nil?
            version_file = File.join(options[:install_base], ".current_version")
            version = File.exists?(version_file) ? File.read(version_file) : options[:version]
            puts "Current version is #{version}"
            exit 0
        end
        options[:version] = version
        version_set = true
    end

    opts.on('-l', '--loud', 'Print detailed output while running') do
        options[:verbose] = true
    end

    opts.on("--noop", "Don't write any files, just output what would be done") do
        options[:noop] = true
    end

    opts.on('-h', '--help', "Print help for this command") do 
        puts opts
        exit 0
    end
end

hopts.parse!

command = ARGV[0] || 'status'

if %w[schema fields].include? command 
    cname = ARGV[1] or raise "[core/collection name] is required for the '#{command}'' command"
end

# functions for querying and persisting current Solr version number

def installed?(server)
    File.directory?(server.instance_dir)
end

def write_version(options)
    vf = options[:version_file]
    vdir = File.basename(vf)
    if not File.directory?(vdir)
        if options[:noop]
            puts "\t[test] would create #{vdir}"
        else
            FileUtils.mkdir_p(vdir)
        end
    end

    if options[:noop] 
        puts "\t[test] would write version '#{options[:version]}' to #{vf}"
    else
        File.open(vf, "w") do |f| 
            f.write(options[:version])
        end
    end
end

def find_version_file(options)
    base_dir = options[:install_base]
    File.join(base_dir, ".current_version")
end

options[:version_file] = find_version_file(options)

# if solr version was set at command line, 
# write that value to a file so it becomes the 
# default version, but ONLY IF
#  1. the version is installed AND
#  2. we are installing or starting
if options.key?(:version)
    temp_server = SolrTasks::Server.new(options)
    if ['install', 'start'].include?(command)
        if installed?(temp_server)
            puts "\tSetting active Solr version to #{options[:version]}"
            write_version(options)
        end
    end
else
    # if version wasn't set at command line, try to read the version
    # file and create it with the default value if it doesn't exist.
    if File.exist?(options[:version_file])
        options[:version] = File.read(options[:version_file])
    else
        options[:version] = options[:default_version]
        write_version(options)
    end
end

server = SolrTasks::Server.new(options)

def status(server)
    if server.is_running? 
        ["Solr is running on port #{server.port}", 0]
    else
        ["Solr is not running on port #{server.port}", 1]
    end
end

def install(server,options)
    if not installed?(server)
        puts "\tSolr not found in #{server.install_dir}."
        if not options[:noop]
            puts "\tStarting installation"
            f = SolrTasks::Fetcher.new(server.install_dir, server.version)
            f.install
        else
            puts "\t[test] Solr #{server.version} would be installed in #{server.install_dir}"
        end
    else
        puts "\tSolr #{server.version} is already installed"
        puts "\t\t#{server.install_dir}"
    end
    write_version(options)
end

def start(server)
    server.start unless server.is_running?
end

def stop(server)
    server.stop if server.is_running?
end

case command 
    when 'install'
        install(server,options)
    when 'status'        
        msg, es = status(server)
        puts msg
        exit es
    when 'start'
        raise "You must 'install 'the server first" if not installed?(server)
        start(server)
    when 'stop'
        stop(server)
    when 'collections'
        puts server.get_collections
    when 'cores'
        puts server.get_cores
    when 'schema'    
            puts server.get_schema(cname, 'schema.xml')
   when 'fields'
           puts server.get_fields(cname)
    else
        puts hopts
        puts  "\n\nUnknown task '#{command}'"
        exit 2
end

